__author__ = "Minghao Gou"
__version__ = "1.0"

import numpy as np
import open3d as o3d
import math
import cv2

X_LENGTH = 1280
Y_LENGTH = 720
NUM_GRID_X = 96
NUM_GRID_Y = 72


def get_camera_intrinsic(camera):
    """
    **Input:**

    - camera: string of type of camera, "realsense" or "kinect".

    **Output:**

    - numpy array of shape (3, 3) of the camera intrinsic matrix.
    """
    param = o3d.camera.PinholeCameraParameters()
    if camera == "kinect":
        param.intrinsic.set_intrinsics(1280, 720, 631.5, 631.2, 639.5, 359.5)
    elif camera == "realsense":
        param.intrinsic.set_intrinsics(1280, 720, 927.17, 927.37, 639.5, 359.5)
    intrinsic = param.intrinsic.intrinsic_matrix
    return intrinsic


def batch_rgbdxyz_2_rgbxy_depth(points, camera):
    """
    **Input:**

    - points: np.array(-1,3) of the points in camera frame (unit: meter)

    - camera: string of the camera type

    **Output:**

    - x: float of x in pixel frame

    - y: float of y in pixel frame

    - z: float of the depths in pixel frame
    """
    intrinsics = get_camera_intrinsic(camera)
    fx, fy = intrinsics[0, 0], intrinsics[1, 1]
    cx, cy = intrinsics[0, 2], intrinsics[1, 2]
    s = 1000.0
    z = s * points[:, 2]  # point_z
    ###################################
    # x and y should be inverted here #
    ###################################
    # y = point[0] / point[2] * fx + cx
    # x = point[1] / point[2] * fy + cy
    # cx = 640, cy = 360
    x = points[:, 0] / points[:, 2] * fx + cx  # 1280
    y = points[:, 1] / points[:, 2] * fy + cy  # 720
    return x, y, z


def framexy_depth_2_xyz(pixel_x, pixel_y, depth, camera):
    """
    **Input:**

    - pixel_x: int of the pixel x coordinate.

    - pixel_y: int of the pixle y coordicate.

    - depth: float of depth. The unit is millimeter.

    - camera: string of type of camera. "realsense" or "kinect".

    **Output:**

    x, y, z: float of x, y and z coordinates in camera frame. The unit is millimeter.
    """
    intrinsics = get_camera_intrinsic(camera)
    fx, fy = intrinsics[0, 0], intrinsics[1, 1]
    cx, cy = intrinsics[0, 2], intrinsics[1, 2]
    z = depth  # mm
    x = z / fx * (pixel_x - cx)  # mm
    y = z / fy * (pixel_y - cy)  # mm
    return x, y, z


def get_grid_points(
    grid_x,
    grid_y,
    num_x=X_LENGTH,
    num_y=Y_LENGTH,
    num_grid_x=NUM_GRID_X,
    num_grid_y=NUM_GRID_Y,
):
    """
    **Input:**

    - grid_x: int of x grid index.

    - grid_y: int of y grid index.

    - num_x: int of number of pixels in x direction.

    - num_y: int of number of pixels in y direction.

    - num_grid_x: int of number of grids in x direction.

    - num_grid_y: int of number of grids in y direction.

    **Output:**

    - numpy array of shape (5, 2).

    - Each of the pair is the pixel coordinate (x, y)

    - The sequence of the points are [top left, top right, bottom left, bottom right, center].
    """
    grid_length = np.array([num_x / num_grid_x, num_y / num_grid_y])
    grid_index = np.array(
        [
            [grid_x, grid_y],
            [grid_x + 1, grid_y],
            [grid_x, grid_y + 1],
            [grid_x + 1, grid_y + 1],
            [grid_x + 0.5, grid_y + 0.5],
        ]
    )
    return (grid_index * grid_length).astype(np.int32)


def get_diag_length(grid_x, grid_y, depth, camera):
    """
    **Input:**

    - grid_x: int of x grid index.

    - grid_y: int of y grid index.

    - depth: float of depth of the point. The unit is millimeter.

    - camera: string of type of the camera. "realsense" or "kinect".

    **Output:**

    - float of the length of the diagonal. The unit is millimeter.
    """
    points_pixel_xy = get_grid_points(grid_x, grid_y)
    top_left_pixel_x, top_left_pixel_y = points_pixel_xy[0]
    bottom_right_pixel_x, bottom_right_pixel_y = points_pixel_xy[3]
    top_left_x, top_left_y, top_left_z = framexy_depth_2_xyz(
        top_left_pixel_x, top_left_pixel_y, depth, camera
    )
    bottom_right_x, bottom_right_y, bottom_right_z = framexy_depth_2_xyz(
        bottom_right_pixel_x, bottom_right_pixel_y, depth, camera
    )
    return math.sqrt(
        (top_left_x - bottom_right_x) ** 2.0 + (top_left_y - bottom_right_y) ** 2.0
    )


def get_z(depths, grid_x, grid_y, delta_z):
    """
    **Input:**

    - depths: numpy array of the depth in the whole image. The unit is millimeter.

    - grid_x: int of x grid index.

    - grid_y: int of y grid index.

    - delta_z: float of delta_z, generated by get_delta_z.

    **Output:**

    - z:  the depth of the grasp. The unit is millimeter.

    - Definition: (z - average(depths in the grid)) / std(depths in the grid)
    """
    points_pixel_xy = get_grid_points(grid_x, grid_y)
    top_left_pixel_x, top_left_pixel_y = points_pixel_xy[0]
    bottom_right_pixel_x, bottom_right_pixel_y = points_pixel_xy[3]
    # x direction is from left to right, y direction is from top to bottom.
    # the first axis of the numpy array is y and the second axis of numpy array is x.
    grid_depths = (
        depths[
            top_left_pixel_y:bottom_right_pixel_y, top_left_pixel_x:bottom_right_pixel_x
        ]
    ).reshape((-1,))
    ave_z = np.mean(grid_depths)
    std_z = np.std(grid_depths)
    return delta_z * std_z + ave_z


def depth_inpaint(depth):
    depth = depth.astype(np.float32)
    fault_mask = depth < 200
    depth[fault_mask] = 0
    inpainting_mask = (np.abs(depth) < 10).astype(np.uint8)
    depths = cv2.inpaint(depth, inpainting_mask, 5, cv2.INPAINT_NS)
    return depths
